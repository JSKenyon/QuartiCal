input_ms:
  path: 
    Path to input measurement set.
  data_column:
    Name of column to use as data.
  weight_column: 
    Column to read weights from. Weights are applied by default. An empty 
    string will result in all weights being treated as unity.
  time_chunk: 
    Chunk data up by this number of timeslots. This limits the amount of data 
    processed at once. Smaller chunks allow for a smaller RAM footprint and 
    greater parallelism, but this sets an upper limit on the solution 
    intervals that may be employed. Specify as an integer number of timeslots, 
    or a value with a unit (e.g. '300s'). 0 means use full time axis.
  freq_chunk:
    Chunk data by this number of channels. See time_chunk for info. Specify as 
    an integer number of channels, or a value with a unit (e.g. '128MHz'). 
    0 means use full frequency axis.
  is_bda:
    If set True, the input measurement set is assumed to have been averaged in 
    a baseline dependent fashion.
  group_by:
    Input data will be partitioned into separate xarray datasets based on the 
    values of the specified columns. Multiple column names may be given as a
    list, e.g. [SCAN_NUMBER, FIELD_ID, DATA_DESC_ID].
  select_corr:
    Select correlations from the input data. These are specified as integer 
    values and must be given as a list e.g. to select the first and last 
    correlations in a measurement set with four correlations, use [0, 3].
  select_fields:
    Select fields from the input data. These are specified as integer 
    values and must be given as a list e.g. to select fields 2 and 6
    use [2, 6].
  select_ddids:
    Select data descriptor IDs (spectral windows) from the input data. These
    are specified as integer values and must be given as a list e.g. to select 
    ddids/SPWs 0 and 2, use [0, 2].
  # chunk-jump:
  #   The jump size used in conjunction with --input-ms-chunk-on. If 0, then any 
  #   change in value is a jump. If n, then the change must be >n.
  # chan:
  #   Channels to read (within each DDID). Default reads all. Multiple channels 
  #   may be given as a list, e.g. [0, 2, 5].
  # rebin_time:
  #   Rebin data in time on the fly. Specify as a number of timeslots to average 
  #   together, or a value with a unit (e.g. '5s').
  # rebin_freq:
  #   Rebin data in frequency on the fly. Specify as a number of channels to 
  #   average together, or a value with a unit (e.g. '4MHz').

input_model:
  recipe: 
    Input model recipe. Add syntactic examples.
  beam: 
    Path to beams. Apply beams during predict if specified eg. 
    'beam_$(corr)_$(reim).fits' or 'beam_$(CORR)_$(REIM).fits'.
  beam_l_axis: 
    Determines the orientation of the beam l-axis. Choose from [X, ~X, 
    Y, ~Y, L, ~L, M, ~M] where ~ indicates flipping the 
    orientation of the axis. 
  beam_m_axis: 
    Determines the orientation of the beam m-axis. See beam_l_axis.
  invert_uvw:
    The UVW coordinates will be negated if this option is specified. Enabled 
    by default.
  source_chunks:
    The number of sources to predict simultaneously. Has a large impact on 
    memory footprint.
  apply_p_jones:
    Determines whether P-Jones is incorporated in the predict. This should 
    usually be left enabled.

output:
  gain_dir:
    Name of directory for output gains.
  products: 
    The desired output data product. Multiple data products can be specified 
    as a list e.g. [residual, corrected_residual]. Choose from [residual, 
    corrected_residual, corrected_data, weights]. All modes generate gains, the
    default doesn't produce a visibility output.
  columns:
    Output MS column names for visibility outputs (if applicable).
    Column names will be used in order, matching the order of output.products.
    Multiple columns can be specified as a list e.g. [COL1, COL2, COL3].
  net_gain:
    Output the effective/net gain per antenna per time per channel. This
    is formed by multiplying all the gain terms together. This can be used
    to reduce the computational load of solution transfer by transferring the
    effective gain rather than each individual term.
  # solver_flags:
  #   Apply solver flags when writing data to measurement set.
  # file_name:
  #   Base name for output files. Full base path will be 
  #   OUTPUT_DIRECTORY[.cc-out]/OUTPUT_FILE_NAMExxx, unless OUTPUT_FILE_NAME 
  #   contains a slash, in which case OUTPUT_DIRECTORY is ignored and 
  #   OUTPUT_FILE_NAME is taken to be a full base path. Defaults to cc.
  # overwrite:
  #   Allow overwriting of existing output files. If this is set, and the output 
  #   parset file exists, will raise an exception.
  # backup:
  #   Allow automatic backup of existing output directories. Automatic backup is 
  #   only used when OUTPUT_DIRECTORY is used (i.e. OUTPUT_FILE_NAME doesn't 
  #   contain any slashes), and it ends with .cc-out (implicitly or explicitly). 
  #   In this case, existing output directories are renamed to .cc.out.0, .1, 
  #   etc.
  # solver_mode:
  #   Solver operational mode. Determines whether gains are solved for or merely 
  #   applied from stored solutions.
  # subtract_directions:
  #   Which model directions to subtract, if generating residuals. May be
  #   specified as a list e.g. [0, 5, 7]. Defaults to 0.
  # plots:
  #   Generate output plots. Defaults to False.
  # casa_tables:
  #   Export gaintables to CASA caltable format. Tables are exported to same 
  #   directory as set for QuartiCal databases.

mad_flags:
  enable:
    Enables the MAD flagging routines.
  threshold_bl:
    Multiplicative factor which determines whether or not a residual is 
    considered to deviate significantly from the median of a given baseline. 
    These values are flagged.
  threshold_global:
    Multiplicative factor which determines whether or not a residual is 
    considered to deviate significantly from the median of the given data 
    chunk. These values are flagged.
  robust:
    Enables Flagging based on the weights. Only use if solver is robust
  

solver:
  terms:
    Gain terms for which we are solving. Multiple terms can be specified as 
    a list e.g. [G,B,dE]. Each term specified here has its own set of 
    arguments which can be specified as (gain).(option). e.g. G.time_interval.
  iter_recipe:
    Specifies the iterations to be performed per gain term. This argument
    expects a list as long or longer than solver.terms. If solver.terms 
    was given as [K,G,B], an iteration recipe of [20,10,5] would do 20 
    iterations for K, 10 for G and 5 for B. To loop over the gains multiple 
    times, use a longer list e.g. [20,10,5,15,5,0] would do the same as 
    the first example but then do an additional 15 iterations for K, 5 for G 
    and skip B. Setting to zero effectively disables solving for that term 
    and can be used in conjunction with iterpolation. 
  robust:
    Enable robust reweighting in solvers.
  v0:
    Initial v-parameter if robust solver is enabled. This should be an integer
    greater than 2. Default value is 30, a value close to implies harsh weigting
    from start.
  robust_iters:
    Number of iterations for which the robust rewieghting is done (Default is 10).
    Same specification as iter_recipe, ideally reweight should be done with the 
    complex solver when in a chain
  cov_thresh:
    Fived the degrees of freedom to 2 if the covariance function exceeds this value.
  robust_thresh:
    Flag data with weights less than this value 
  threads:
    Number of Numba threads per Dask thread (enables nested parallelism) to
    be used when running the solvers. The total number of threads used will be 
    dask.threads*solver.threads; if this product exceeds the number of 
    available threads, performance will suffer.
  # mode:
  #   The mode in which the solver should operate. This is assumed to be the 
  #   same for all terms specified by --solver-gain-terms. The first part of 
  #   each option refers to the gain and the second to the visibilities. Thus, 
  #   "full-full" means both the gains and the visibilities have four 
  #   correlations, "diag-full" has diagonal gains and "diag-diag" implies 
  #   that both the gains and visibilities are diagonal. Specifying "scalar" 
  #   will assume both gains and visibilitites are scalar.
  # chisq_interval:
  #   Number of iterations to perform between chi-squared checks. This is done 
  #   to avoid computing the expensive chi-squared test every iteration.
  # stall_fraction:
  #   Minimum percentage of solutions which must have stalled (the chi-squared 
  #   values are no longer improving) before terminating the solver.
    
dask:
  threads:
    Number of threads to use in the dask scheduler. Setting to zero (the 
    default) will use all available resources.
  workers:
    Number of workers to use in the dask distributed scheduler. Advanced users 
    only.
  address:
    Distributed scheduler address.
  scheduler:
    Which dask scheduler to use. The default, threads, is the most appropriate 
    for non-cluster use. Choose from [threads, distributed, single-threaded].

gain:
  type:
    Type of gain to solve for. Choose from [complex, phase, delay].
  direction_dependent:
    Determines whether this term is treated as direction dependent.
  time_interval:
    Number of timeslots/amount of time to include in a single solution. 
    Specify as an integer number of timeslots, or a value with a unit 
    (e.g. '300s'). 0 means use full time axis.
  freq_interval:
    Number of channels/bandwidth to include in a single solution. Specify as 
    an integer number of channels, or a value with a unit (e.g. '128MHz'). 
    0 means use full frequency axis.
  load_from:
    Load solutions from given database. 
  interp_mode:
    Set interpolation mode. Choose from [ampphase, reim].
  interp_method:
    Set interpolation method. Choose from [2dlinear, 2dspline, 
    smoothingspline]. The smoothing spline implementation is is experimental 
    and slow.
  # parametrisation:
  #       type: str
  #       help: If the gain is parametric, this determines the type of
  #             parametrisation.
  #       choices:
  #           - f-slope
  #           - t-slope
  #           - tf-plane
  #       default: f-slope
  #   restrict-update:
  #       type: str
  #       help: Determines update restrictions. This does not change the solver
  #             type, but instead restricts the update rule.
  #       choices:
  #             - default
  #             - diagonal
  #             - diagonal-phase
  #             - diagonal-amp
  #       default: default
  #   exclude-directions:
  #       nargs: +
  #       type: int
  #       help: For direction-dependent terms, makes the listed directions
  #             (specified by index) non-solvable. -1 disables.
  #       default: -1
  #   delta-threshold:
  #       type: float
  #       help: Convergence threshold. Solutions that change by less than this
  #             value are considered converged.
  #       default: 1e-6
  #   chisq-threshold:
  #       type: float
  #       help: Threshold for solution stagnancy - if the relative improvement in
  #             the chi-squared is less than this value, then the solution is
  #             marked as stalled.
  #       default: 1e-6
  #   conv-fraction:
  #       type: float
  #       help: Fraction of solutions required to converge before terminating the
  #             solver.
  #       default: 0.99
  #   reference-antenna:
  #       type: int
  #       help: Reference antenna - its phase is guaranteed to be zero.
  #             -1 disables.
  #       default: -1
  #   upper-clip:
  #       type: float
  #       help: Amplitude clipping - flag solutions with amplitudes above this
  #             value. 0 disables. Disabled by default.
  #       default: 0
  #   lower-clip:
  #       type: float
  #       help: Amplitude clipping - flag solutions with any amplitudes below
  #             this value. 0 disables. Disabled by default.
  #       default: 0
  #   clip-interval:
  #       type: int
  #       help: Number of iterations to perform between clips.
  #       default: 5
  #   precomputed:
  #       type: bool
  #       help: Set to 1 (and specify load-from or xfer-from) to load a
  #             precomputed term from disk.
  #       default: False
  #   xfer-from:
  #       type: str
  #       help: Transfer solutions from given database. Similar to -load-from,
  #             but solutions will be interpolated onto the required
  #             time/frequency grid, so they can originate from a different field
  #             (e.g. from a calibrator).
  #       default: None
  #   save-to:
  #       type: str
  #       help: Save solutions to given database.
  #       default: None