# -*- coding: utf-8 -*-
import dask.array as da
from quartical.data_handling.predict import predict
from loguru import logger  # noqa


def add_model_graph(ms_xds, opts):
    """Creates the graph necessary to produce a model per xds.

    Given a list of input xarray data sets and the options, constructs a graph
    in accordance with the internal model recipe. This can produce
    direction-dependent models using the recipe syntax.

    Args:
        ms_xds: A list of xarray datasets generated from an MS.
        opts: The options Namepsace.

    Returns:
        model_xds_list: A list of xarray datasets containing the model data.
    """

    # Generates a predicition scheme (graph) per-xds. If no predict is
    # required, it is a list of empty dictionaries.

    predict_schemes = \
        predict(ms_xds, opts) if opts._predict else [{}]*len(ms_xds)

    # Initialise a list to contain the xdss after the model data has been
    # assigned.

    model_xds_list = []

    # Loops over the xdss and prediciton schemes.

    for xds, prediction in zip(ms_xds, predict_schemes):

        model = []  # A list to contain the model generated by the recipe.

        for recipe in opts._internal_recipe.values():

            ingredients = recipe[::2]  # Columns/sky models.
            operations = recipe[1::2]  # Add or subtract operations.

            if not operations:  # Handle recipe components without operations.
                if ingredients[0] in prediction.keys():
                    result = prediction.get(ingredients[0])
                else:
                    result = [xds.get(ingredients[0]).data]  # Must be a list.

                model.extend(result)

                continue

            # If we have operations, we loop over them to construct the model.

            for op_idx, op in enumerate(operations):

                # The first operation will require two inputs. Thereafter,
                # the result of the previous operation will be one of the
                # inputs. If the first ingredient is an empty string, we must
                # have a leading operation, usually a negative. For simplicity,
                # a leading negative is implemented by subtracting the first
                # ingredient from zero.

                if op_idx == 0:
                    if ingredients[op_idx] == "":
                        in_a = [0]
                    elif ingredients[op_idx] in prediction.keys():
                        in_a = prediction.get(ingredients[op_idx])
                    else:
                        in_a = [xds.get(ingredients[op_idx]).data]

                if ingredients[op_idx + 1] in prediction.keys():
                    in_b = prediction.get(ingredients[op_idx + 1])
                else:
                    in_b = [xds.get(ingredients[op_idx + 1]).data]

                # Adding and subtracting direction dependent models is not
                # supported. If we have an operation with a single
                # direction-dependent term, it is assumed to apply to the first
                # direction only.

                if len(in_a) > 1 and len(in_b) > 1:
                    raise(ValueError("Model recipes do not support add or "
                                     "subtract operations between two "
                                     "direction-dependent inputs."))
                elif len(in_a) > len(in_b):
                    result = [op(in_a[0], in_b[0]), *in_a[1:]]
                elif len(in_a) < len(in_b):
                    result = [op(in_a[0], in_b[0]), *in_b[1:]]
                else:
                    result = [op(in_a[0], in_b[0])]
                in_a = result

            model.extend(result)  # Add terms generated by the operations.

        n_dir = len(model)  # The number of terms is the number of directions.

        # This creates the direction axis by stacking the model terms. The
        # rechunking is necessary to ensure the solver gets appropriate blocks.
        model = da.stack(model, axis=2).rechunk({2: n_dir})

        # This pulls out just the diagonal terms in the case that we are doing
        # diagonal only calibration. TODO: This is easy but needlessly
        # predicts all correlations.
        if opts.input_ms_correlation_mode == "diag" and model.shape[-1] == 4:
            model = model[..., ::3]

        modified_xds = xds.assign({"MODEL_DATA":
                                  (("row", "chan", "dir", "corr"), model)})

        model_xds_list.append(modified_xds)

    return model_xds_list
